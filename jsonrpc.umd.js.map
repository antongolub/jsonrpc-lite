{"version":3,"file":"jsonrpc.umd.js","sources":["jsonrpc.ts"],"sourcesContent":["// **Github:** https://github.com/teambition/jsonrpc-lite\n//\n// http://www.jsonrpc.org/specification\n// **License:** MIT\n'use strict'\n\nexport type ID = string | number\nexport type Defined = string | number | boolean | object | null\nexport type RpcParams = object | Defined[]\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst isInteger: (num: number) => boolean = typeof Number.isSafeInteger === 'function'\n  ? Number.isSafeInteger // ECMAScript 2015\n  : function (num) {\n    return typeof num === 'number' && isFinite(num) && num === Math.floor(num) && Math.abs(num) <= 9007199254740991\n  }\n\n/**\n * JsonRpc Class\n *\n * @return {Object} JsonRpc object\n * @api public\n */\nexport interface IJsonRpcType {\n  readonly jsonrpc: string\n}\n\nexport class JsonRpc implements IJsonRpcType {\n  static VERSION: string = '2.0'\n  readonly jsonrpc: string\n\n  constructor () {\n    this.jsonrpc = '2.0'\n  }\n\n  serialize () {\n    return JSON.stringify(this)\n  }\n\n}\n\nexport class RequestObject extends JsonRpc {\n  public id: ID\n  public method: string\n  public params?: RpcParams\n  constructor (id: ID, method: string, params?: RpcParams) {\n    super()\n    this.id = id\n    this.method = method\n    if (params !== undefined ) {\n      this.params = params\n    }\n  }\n}\n\nexport class NotificationObject extends JsonRpc {\n  public method: string\n  public params?: RpcParams\n  constructor (method: string, params?: RpcParams) {\n    super()\n    this.method = method\n    if (params !== undefined ) {\n      this.params = params\n    }\n  }\n}\n\nexport class SuccessObject extends JsonRpc {\n  public id: ID\n  public result: Defined\n  constructor (id: ID, result: Defined) {\n    super()\n    this.id = id\n    this.result = result\n  }\n}\n\nexport class ErrorObject extends JsonRpc {\n  // tslint:disable-next-line:no-shadowed-variable\n  constructor (public id: ID, public error: JsonRpcError) {\n    super()\n    this.id = id\n    this.error = error\n  }\n}\n\n/**\n * JsonRpcParsed Class\n *\n * @param  {JsonRpc|JsonRpcError} payload\n * @param  {type: <Enum, 'request'|'notification'|'success'|'error'|'invalid'>} type\n * @api public\n */\nexport const enum RpcStatusType {\n  request = 'request',\n  notification = 'notification',\n  success = 'success',\n  error = 'error',\n  invalid = 'invalid',\n}\n\nexport class JsonRpcParsed {\n  constructor (\n    public payload: JsonRpc | JsonRpcError,\n    public type: RpcStatusType,\n  ) {\n    this.payload = payload\n    this.type = type\n  }\n}\n\n/**\n * JsonRpcError Class\n *\n * @param  {String} message\n * @param  {Integer} code\n * @return {String} name: optional\n * @api public\n */\nexport class JsonRpcError {\n  static invalidRequest = function (data: any): JsonRpcError {\n    return new JsonRpcError('Invalid request', -32600, data)\n  }\n\n  static methodNotFound = function (data: any): JsonRpcError {\n    return new JsonRpcError('Method not found', -32601, data)\n  }\n\n  static invalidParams = function (data: any): JsonRpcError {\n    return new JsonRpcError('Invalid params', -32602, data)\n  }\n\n  static internalError = function (data: any): JsonRpcError {\n    return new JsonRpcError('Internal error', -32603, data)\n  }\n\n  static parseError = function (data: any): JsonRpcError {\n    return new JsonRpcError('Parse error', -32700, data)\n  }\n\n  public message: string\n  public code: number\n  public data?: any\n  constructor (message: string, code: number, data?: any) {\n    this.message = message\n    this.code = isInteger(code) ? code : 0\n    if (data != null ) {\n      this.data = data\n    }\n  }\n}\n\n/**\n * Creates a JSON-RPC 2.0 request object\n *\n * @param  {String|Integer} id\n * @param  {String} method\n * @param  {Object|Array} [params]: optional\n * @return {Object} JsonRpc object\n * @api public\n */\nexport function request (\n  id: ID,\n  method: string,\n  params?: RpcParams,\n): RequestObject {\n  const object = new RequestObject(id, method, params)\n  validateMessage(object, true)\n  return object\n}\n\n/**\n * Creates a JSON-RPC 2.0 notification object\n *\n * @param  {String} method\n * @param  {Object|Array} [params]: optional\n * @return {Object} JsonRpc object\n * @api public\n */\nexport function notification (\n  method: string,\n  params?: RpcParams,\n): NotificationObject {\n  const object = new NotificationObject(method, params)\n  validateMessage(object, true)\n  return object\n}\n\n/**\n * Creates a JSON-RPC 2.0 success response object\n *\n * @param  {String|Integer} id\n * @param  {Mixed} result\n * @return {Object} JsonRpc object\n * @api public\n */\nexport function success (id: ID, result: Defined): SuccessObject {\n  const object = new SuccessObject(id, result)\n  validateMessage(object, true)\n  return object\n}\n\n/**\n * Creates a JSON-RPC 2.0 error response object\n *\n * @param  {String|Integer} id\n * @param  {Object} JsonRpcError error\n * @return {Object} JsonRpc object\n * @api public\n */\nexport function error (id: ID, err: JsonRpcError): ErrorObject {\n  const object = new ErrorObject(id, err)\n  validateMessage(object, true)\n  return object\n}\n\nexport interface IParsedObjectSuccess {\n  type: RpcStatusType.success,\n  payload: SuccessObject\n}\n\nexport interface IParsedObjectNotification {\n  type: RpcStatusType.notification,\n  payload: NotificationObject\n}\n\nexport interface IParsedObjectRequest {\n  type: RpcStatusType.request,\n  payload: RequestObject\n}\n\nexport interface IParsedObjectError {\n  type: RpcStatusType.error,\n  payload: ErrorObject\n}\n\nexport interface IParsedObjectInvalid {\n  type: RpcStatusType.invalid,\n  payload: JsonRpcError\n}\n\n/**\n * Takes a JSON-RPC 2.0 payload (String) and tries to parse it into a JSON.\n * If successful, determine what object is it (response, notification,\n * success, error, or invalid), and return it's type and properly formatted object.\n *\n * @param  {String} msg\n * @return {Object|Array} an array, or an object of this format:\n *\n *  {\n *    type: <Enum, 'request'|'notification'|'success'|'error'|'invalid'>\n *    payload: <JsonRpc|JsonRpcError>\n *  }\n *\n * @api public\n */\nexport type IParsedObject = IParsedObjectSuccess | IParsedObjectNotification |\n  IParsedObjectRequest | IParsedObjectError| IParsedObjectInvalid;\n\nexport function parse (\n  message: string,\n): IParsedObject | IParsedObject[] {\n  if (!isString(message)) {\n    return new JsonRpcParsed(\n      JsonRpcError.invalidRequest(message),\n      RpcStatusType.invalid,\n    ) as IParsedObject\n  }\n\n  let jsonrpcObj: JsonRpc | JsonRpc[]\n  try {\n    jsonrpcObj = JSON.parse(message)\n  } catch (err) {\n    return new JsonRpcParsed(\n      JsonRpcError.parseError(message),\n      RpcStatusType.invalid,\n    ) as IParsedObject\n  }\n\n  return parseJsonRpcObject(jsonrpcObj)\n}\n\n/**\n * Takes a JSON-RPC 2.0 payload (Object) or batch (Object[]) and tries to parse it.\n * If successful, determine what objects are inside (response, notification,\n * success, error, or invalid), and return their types and properly formatted objects.\n *\n * @param  {Object|Array} jsonrpcObj\n * @return {Object|Array} a single object or an array of `JsonRpcParsed` objects with `type` and `payload`:\n *\n *  {\n *    type: <Enum, 'request'|'notification'|'success'|'error'|'invalid'>\n *    payload: <JsonRpc|JsonRpcError>\n *  }\n *\n * @api public\n */\nexport function parseJsonRpcObject (jsonrpcObj: JsonRpc | JsonRpc[]): IParsedObject | IParsedObject[] {\n  if (!Array.isArray(jsonrpcObj)) {\n    return parseObject(jsonrpcObj)\n  }\n\n  if (jsonrpcObj.length === 0) {\n    return new JsonRpcParsed(\n      JsonRpcError.invalidRequest(jsonrpcObj),\n      RpcStatusType.invalid,\n    ) as IParsedObject\n  }\n\n  const parsedObjectArray: IParsedObject[] = []\n  for (let i = 0, len = jsonrpcObj.length; i < len; i++) {\n    parsedObjectArray[i] = parseObject(jsonrpcObj[i])\n  }\n\n  return parsedObjectArray\n}\n\n/**\n * Alias for `parse` method.\n * Takes a JSON-RPC 2.0 payload (String) and tries to parse it into a JSON.\n * @api public\n */\nexport const parseJsonRpcString = parse\n\n/**\n * Takes a JSON-RPC 2.0 payload (Object) and tries to parse it into a JSON.\n * If successful, determine what object is it (response, notification,\n * success, error, or invalid), and return it's type and properly formatted object.\n *\n * @param  {Object} obj\n * @return {Object} an `JsonRpcParsed` object with `type` and `payload`:\n *\n *  {\n *    type: <Enum, 'request'|'notification'|'success'|'error'|'invalid'>\n *    payload: <JsonRpc|JsonRpcError>\n *  }\n *\n * @api public\n */\nexport function parseObject (obj: any): IParsedObject {\n  let err: JsonRpcError | null = null\n  let payload: JsonRpc | JsonRpcError | null = null\n  let payloadType: RpcStatusType = RpcStatusType.invalid\n\n  if (obj == null || obj.jsonrpc !== JsonRpc.VERSION) {\n    err = JsonRpcError.invalidRequest(obj)\n    payloadType = RpcStatusType.invalid\n  } else if (!hasOwnProperty.call(obj, 'id')) {\n    const tmp = obj as NotificationObject\n    payload = new NotificationObject(tmp.method, tmp.params)\n    err = validateMessage(payload)\n    payloadType = RpcStatusType.notification\n  } else if (hasOwnProperty.call(obj, 'method')) {\n    const tmp = obj as RequestObject\n    payload = new RequestObject(tmp.id, tmp.method, tmp.params)\n    err = validateMessage(payload)\n    payloadType = RpcStatusType.request\n  } else if (hasOwnProperty.call(obj, 'result')) {\n    const tmp = obj as SuccessObject\n    payload = new SuccessObject(tmp.id, tmp.result)\n    err = validateMessage(payload)\n    payloadType = RpcStatusType.success\n  } else if (hasOwnProperty.call(obj, 'error')) {\n    const tmp = obj as ErrorObject\n    payloadType = RpcStatusType.error\n    if (tmp.error == null) {\n      err = JsonRpcError.internalError(tmp)\n    } else {\n      const errorObj = new JsonRpcError(\n        tmp.error.message,\n        tmp.error.code,\n        tmp.error.data,\n      )\n      if (errorObj.message !== tmp.error.message || errorObj.code !== tmp.error.code) {\n        err = JsonRpcError.internalError(tmp)\n      } else {\n        payload = new ErrorObject(tmp.id, errorObj)\n        err = validateMessage(payload)\n      }\n    }\n  }\n\n  if (err == null && payload != null) {\n    return new JsonRpcParsed(payload, payloadType) as IParsedObject\n  }\n  return new JsonRpcParsed(\n    err != null ? err : JsonRpcError.invalidRequest(obj),\n    RpcStatusType.invalid,\n  ) as IParsedObject\n}\n\n// if error, return error, else return null\nfunction validateMessage (obj: JsonRpc, throwIt?: boolean): JsonRpcError | null {\n  let err: JsonRpcError | null = null\n  if (obj instanceof RequestObject) {\n    err = checkId(obj.id)\n    if (err == null) {\n      err = checkMethod(obj.method)\n    }\n    if (err == null) {\n      err = checkParams(obj.params)\n    }\n  } else if (obj instanceof NotificationObject) {\n    err = checkMethod(obj.method)\n    if (err == null) {\n      err = checkParams(obj.params)\n    }\n  } else if (obj instanceof SuccessObject) {\n    err = checkId(obj.id)\n    if (err == null) {\n      err = checkResult(obj.result)\n    }\n  } else if (obj instanceof ErrorObject) {\n    err = checkId(obj.id, true)\n    if (err == null) {\n      err = checkError(obj.error as JsonRpcError)\n    }\n  }\n  if (throwIt && err != null) {\n    throw err\n  }\n  return err\n}\n\nfunction checkId (id: ID, maybeNull?: boolean): JsonRpcError | null {\n  if (maybeNull && id === null) {\n    return null\n   }\n  return isString(id) || isInteger(id as number)\n    ? null\n    : JsonRpcError.internalError('\"id\" must be provided, a string or an integer.')\n}\n\nfunction checkMethod (method: string): JsonRpcError | null {\n  return isString(method) ? null : JsonRpcError.invalidRequest(method)\n}\n\nfunction checkResult (result: Defined): JsonRpcError | null {\n  return result === undefined\n    ? JsonRpcError.internalError('Result must exist for success Response objects')\n    : null\n}\n\nfunction checkParams (params?: RpcParams): JsonRpcError | null {\n  if (params === undefined) {\n    return null\n  }\n  if (Array.isArray(params) || isObject(params)) {\n    // ensure params can be stringify\n    try {\n      JSON.stringify(params)\n      return null\n    } catch (err) {\n      return JsonRpcError.parseError(params)\n    }\n  }\n  return JsonRpcError.invalidParams(params)\n}\n\nfunction checkError (err: JsonRpcError): JsonRpcError | null {\n  if (!(err instanceof JsonRpcError)) {\n    return JsonRpcError.internalError('Error must be an instance of JsonRpcError')\n  }\n\n  if (!isInteger(err.code)) {\n    return JsonRpcError.internalError('Invalid error code. It must be an integer.')\n  }\n\n  if (!isString(err.message)) {\n    return JsonRpcError.internalError('Message must exist or must be a string.')\n  }\n\n  return null\n}\n\nfunction isString (obj: any): boolean {\n  return obj !== '' && typeof obj === 'string'\n}\n\nfunction isObject (obj: any): boolean {\n  return obj != null && typeof obj === 'object' && !Array.isArray(obj)\n}\n\nconst jsonRpcGlobal = {\n  JsonRpc,\n  JsonRpcError,\n  request,\n  notification,\n  success,\n  error,\n  parse,\n  parseObject,\n  parseJsonRpcObject,\n  parseJsonRpcString,\n}\n\nexport default jsonRpcGlobal\nexport const jsonrpc: typeof jsonRpcGlobal = jsonRpcGlobal\n\ndeclare global {\n  const jsonrpc: typeof jsonRpcGlobal\n\n  interface Window { jsonrpc: typeof jsonRpcGlobal }\n}\n\n((global || window) as any).jsonrpc = jsonRpcGlobal // tslint:disable-line\n"],"names":["const","hasOwnProperty","Object","prototype","isInteger","Number","isSafeInteger","num","isFinite","Math","floor","abs","JsonRpc","constructor","jsonrpc","serialize","JSON","stringify","this","RequestObject","id","method","params","undefined","NotificationObject","SuccessObject","result","ErrorObject","error","JsonRpcParsed","payload","type","JsonRpcError","message","code","data","request","object","validateMessage","notification","success","err","parse","isString","invalidRequest","jsonrpcObj","parseError","parseJsonRpcObject","Array","isArray","parseObject","length","parsedObjectArray","i","len","parseJsonRpcString","obj","payloadType","VERSION","call","tmp","internalError","errorObj","throwIt","checkId","checkMethod","checkParams","checkError","maybeNull","invalidParams","jsonRpcGlobal","global","window"],"mappings":"iLAUAA,IAAMC,EAAiBC,OAAOC,UAAUF,eAClCG,EAAsE,mBAAzBC,OAAOC,cACtDD,OAAOC,cACP,SAAUC,SACY,iBAARA,GAAoBC,SAASD,IAAQA,IAAQE,KAAKC,MAAMH,IAAQE,KAAKE,IAAIJ,IAAQ,kBAatFK,EAIXC,gBACOC,QAAU,OAGjBC,YAAAA,4BACSC,KAAKC,UAAUC,OARjBN,UAAkB,UAadO,cAIXN,WAAaO,EAAQC,EAAgBC,qBAE9BF,GAAKA,OACLC,OAASA,OACCE,IAAXD,SACGA,OAASA,0FATeV,GActBY,cAGXX,WAAaQ,EAAgBC,qBAEtBD,OAASA,OACCE,IAAXD,SACGA,OAASA,0FAPoBV,GAY3Ba,cAGXZ,WAAaO,EAAQM,qBAEdN,GAAKA,OACLM,OAASA,yFANiBd,GAUtBe,cAEXd,WAAoBO,EAAeQ,wBAAfR,aAAeQ,OAE5BR,GAAKA,OACLQ,MAAQA,yFALgBhB,GAwBpBiB,EACXhB,SACSiB,EACAC,gBADAD,YACAC,OAEFD,QAAUA,OACVC,KAAOA,GAYHC,EAwBXnB,SAAaoB,EAAiBC,EAAcC,QACrCF,QAAUA,OACVC,KAAO9B,EAAU8B,GAAQA,EAAO,EACzB,MAARC,SACGA,KAAOA,aAcFC,EACdhB,EACAC,EACAC,OAEMe,EAAS,IAAIlB,EAAcC,EAAIC,EAAQC,UAC7CgB,EAAgBD,GAAQ,GACjBA,WAWOE,EACdlB,EACAC,OAEMe,EAAS,IAAIb,EAAmBH,EAAQC,UAC9CgB,EAAgBD,GAAQ,GACjBA,WAWOG,EAASpB,EAAQM,OACzBW,EAAS,IAAIZ,EAAcL,EAAIM,UACrCY,EAAgBD,GAAQ,GACjBA,WAWOT,EAAOR,EAAQqB,OACvBJ,EAAS,IAAIV,EAAYP,EAAIqB,UACnCH,EAAgBD,GAAQ,GACjBA,WA8COK,EACdT,OAEKU,EAASV,UACL,IAAIJ,EACTG,EAAaY,eAAeX,kBAK5BY,MAEFA,EAAa7B,KAAK0B,MAAMT,GACxB,MAAOQ,UACA,IAAIZ,EACTG,EAAac,WAAWb,qBAKrBc,EAAmBF,YAkBZE,EAAoBF,OAC7BG,MAAMC,QAAQJ,UACVK,EAAYL,MAGK,IAAtBA,EAAWM,cACN,IAAItB,EACTG,EAAaY,eAAeC,sBAK1BO,EAAqC,GAClCC,EAAI,EAAGC,EAAMT,EAAWM,OAAQE,EAAIC,EAAKD,IAChDD,EAAkBC,GAAKH,EAAYL,EAAWQ,WAGzCD,EAlMApB,iBAAiB,SAAUG,UACzB,IAAIH,EAAa,mBAAoB,MAAOG,IAG9CH,iBAAiB,SAAUG,UACzB,IAAIH,EAAa,oBAAqB,MAAOG,IAG/CH,gBAAgB,SAAUG,UACxB,IAAIH,EAAa,kBAAmB,MAAOG,IAG7CH,gBAAgB,SAAUG,UACxB,IAAIH,EAAa,kBAAmB,MAAOG,IAG7CH,aAAa,SAAUG,UACrB,IAAIH,EAAa,eAAgB,MAAOG,QAyLtCoB,EAAqBb,WAiBlBQ,EAAaM,OACvBf,EAA2B,KAC3BX,EAAyC,KACzC2B,eAEO,MAAPD,GAAeA,EAAI1C,UAAYF,EAAQ8C,QACzCjB,EAAMT,EAAaY,eAAeY,GAClCC,iBACK,GAAKxD,EAAe0D,KAAKH,EAAK,OAK9B,GAAIvD,EAAe0D,KAAKH,EAAK,UAGlCf,EAAMH,EADNR,EAAU,IAAIX,EADFqC,EACoBpC,GADpBoC,EAC4BnC,OAD5BmC,EACwClC,SAEpDmC,iBACK,GAAIxD,EAAe0D,KAAKH,EAAK,UAGlCf,EAAMH,EADNR,EAAU,IAAIL,EADF+B,EACoBpC,GADpBoC,EAC4B9B,SAExC+B,iBACK,GAAIxD,EAAe0D,KAAKH,EAAK,SAAU,KACtCI,EAAMJ,KACZC,UACiB,MAAbG,EAAIhC,MACNa,EAAMT,EAAa6B,cAAcD,OAC5B,KACCE,EAAW,IAAI9B,EACnB4B,EAAIhC,MAAMK,QACV2B,EAAIhC,MAAMM,KACV0B,EAAIhC,MAAMO,MAGVM,EADEqB,EAAS7B,UAAY2B,EAAIhC,MAAMK,SAAW6B,EAAS5B,OAAS0B,EAAIhC,MAAMM,KAClEF,EAAa6B,cAAcD,GAG3BtB,EADNR,EAAU,IAAIH,EAAYiC,EAAIxC,GAAI0C,WA1BtCrB,EAAMH,EADNR,EAAU,IAAIN,EADFgC,EACyBnC,OADzBmC,EACqClC,SAEjDmC,wBA+BS,MAAPhB,GAA0B,MAAXX,EACV,IAAID,EAAcC,EAAS2B,GAE7B,IAAI5B,EACF,MAAPY,EAAcA,EAAMT,EAAaY,eAAeY,cAMpD,SAASlB,EAAiBkB,EAAcO,OAClCtB,EAA2B,QAC3Be,aAAerC,GAEN,OADXsB,EAAMuB,EAAQR,EAAIpC,OAEhBqB,EAAMwB,EAAYT,EAAInC,SAEb,MAAPoB,IACFA,EAAMyB,EAAYV,EAAIlC,UAEfkC,aAAehC,EAEb,OADXiB,EAAMwB,EAAYT,EAAInC,WAEpBoB,EAAMyB,EAAYV,EAAIlC,SAEfkC,aAAe/B,EAEb,OADXgB,EAAMuB,EAAQR,EAAIpC,OAEhBqB,OA4BclB,IA5BIiC,EAAI9B,OA6BtBM,EAAa6B,cAAc,kDAC3B,MA5BOL,aAAe7B,GAEb,OADXc,EAAMuB,EAAQR,EAAIpC,IAAI,MAEpBqB,EA4CN,SAAqBA,UACbA,aAAeT,EAIhB5B,EAAUqC,EAAIP,MAIdS,EAASF,EAAIR,SAIX,KAHED,EAAa6B,cAAc,2CAJ3B7B,EAAa6B,cAAc,8CAJ3B7B,EAAa6B,cAAc,6CA9C1BM,CAAWX,EAAI5B,QAGrBmC,GAAkB,MAAPtB,QACPA,SAEDA,EAGT,SAASuB,EAAS5C,EAAQgD,UACpBA,GAAoB,OAAPhD,EACR,KAEFuB,EAASvB,IAAOhB,EAAUgB,GAC7B,KACAY,EAAa6B,cAAc,kDAGjC,SAASI,EAAa5C,UACbsB,EAAStB,GAAU,KAAOW,EAAaY,eAAevB,GAS/D,SAAS6C,EAAa5C,WACLC,IAAXD,SACK,QAEL0B,MAAMC,QAAQ3B,IAiCJ,OADGkC,EAhCqBlC,IAiCD,iBAARkC,IAAqBR,MAAMC,QAAQO,cA9B5DxC,KAAKC,UAAUK,GACR,KACP,MAAOmB,UACAT,EAAac,WAAWxB,GA0BrC,IAAmBkC,SAvBVxB,EAAaqC,cAAc/C,GAmBpC,SAASqB,EAAUa,SACF,KAARA,GAA6B,iBAARA,EAO9BxD,IAAMsE,EAAgB,SACpB1D,eACAoB,UACAI,eACAG,UACAC,QACAZ,QACAc,cACAQ,qBACAH,qBACAQ,GAIWzC,EAAgCwD,GAQ3CC,QAAUC,QAAgB1D,QAAUwD"}